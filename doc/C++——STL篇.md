[TOC]



# C++——STL篇

## 简介

什么是STL？

简单来说，是C++语言中，为了提高代码的复用性而加入的标准模板库(Standard Template Library)。STL不仅提供了常用的数据结构（如栈、数组等）还提供了一些常用算法。因此熟练使用STL库可以提高编程效率，减少出错可能，美观代码，更好地使用C++完成一些高难度任务，而不是忙于造轮子。

STL有六大组件

- 容器(Containers) 各种各样的数据结构，有顺序的（如vector、list、array），也有组合式的（如set、map）也有非顺序的（如unordered_set）有不同的功能，适用于不同的场合，但本质就是class template
- 算法(Algorithms) 提供各种常用算法，比如sort、search、copy等
- 迭代器(Iterators) 可以把迭代器理解成一个万能的指针，它们都实现了指针相关的运算，如`operator*`、`operator->`，几乎所有的STL容器都有自己的迭代器，用于遍历自己的元素。
- 仿函数(functors) 这是一种重载了`operator()`的class或者class template，可以理解为一种高级的函数指针。
- 配接器(Adapters) 有时候，配接器被归在了容器内部，但其实配接器有些不同于容器，如queue、stack，它们的底层事实上都完全借助deque实现。
- 配置器(allocators) 用于分配内存空间，负责管理空间配置的class template

我对仿函数的理解不够深刻，一开始甚至不懂仿函数是在干什么，这里有个[例子](../src/STL/introduction)：

```C++
template<class T>
class print {
public:
    void operator() (const T & elem) {
        cout << elem << endl;
    };
};

int main(int argc, char const *argv[])
{
    vector<int> a{1,2,3,4,5};
    for_each(a.begin(), a.end(), print<int>());
}
```

这里的`class print`就是仿函数，重载了`operator()`的class template。这里最后一行，就是用`print<int>`的一个临时对象，传入到`for_each()`中，进行打印操作，用法非常类似于函数指针。

那么，仿函数与函数指针的区别在哪里呢？首先，仿函数是一个对象，对象就可以有自己的内部状态，可以根据自身的状态不同来作出不同的反应，这是函数指针做不到的。比如之前的例子中，若`print`类中再添加一个成员变量，根据成员变量的数值来决定输出格式，这是函数指针做不到的。当然你可以说函数指针使用静态变量来完成，但静态变量又有可能被其他程序修改导致不确定性，封装也没有对象好。其次，编译器可以内联(inline)仿函数，而函数指针不能这样，因此效率会高一些。

## 配置器

### 关于空闲块链表

STL作为一个C++标准库，效率是非常关键的指标。理解STL源码，必须要理解为什么STL有这么高的运行效率，理解为提升效率编写者的良苦用心。

回归正题，小额区块带来的内存碎片是非常头疼的，系统不仅要配置并维护内存碎片，而且还需要额外的空间去管理记录，这都是很沉重的管理负担。内存碎片的存在还会使得内存利用不充分，浪费宝贵的内存空间。

为解决（或者说缓解）这一问题，SGI STL实现了二级配置器，二级配置器从内存池中索要分配空间，并将空闲的块用**自由链表**维护。这相当于给所有的内存碎片用链表串起来，在遇到一些符合要求的内存需求时，直接从链表中拨出，这样可以充分利用内存碎片，也就提高了效率。