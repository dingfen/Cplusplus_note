# 算法篇

[TOC]

## 排序

### 逆序对数量

问题：假设A[1..n]是一个有n个不同数的数组，若`i<j`且`a[i]>a[j]`，则对偶`(i, j)`称为A的一个逆序对(inversion)。给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况下需要`o(nlgn)`的时间复杂度。

分析：[实现代码](../src/algorithms/ch2-base/inversion.cpp)

算法的思路是从**排序的过程**中来计算逆序对，因为排序正是修正逆序的过程。既然复杂度要控制在`O(nlgn)`以内，以现在接触的算法来说，可选用归并排序。

那么归并排序的过程中如何去确定逆序对的数量呢？首先，对于归并排序来讲，分解、解决、合并三步里的合并步骤是解决问题的关键，在**合并**这一步中，L与R两个子数组中的数都是相对有序的，并且L数组的下标都是小于R数组的下标的。这样一来，**出现逆序对的地方，就只能是在L中出现某个值x比R数组中的值y大**。并且，排在x之后的所有值也必然要比y的值要大，这样我们就求得了在当前合并步骤中与y相关的逆序对的总量。

那么这样计算有无遗漏呢？由于在归并排序中，每次从L、R数组中取出的数都是**未排元素中的最小值**。因此不会出现R数组中的某数y丢失逆序对的情况，因为此时L数组中所有的已经归并的元素绝不可能比y要大。

## 堆

### 合并k个链表

问题：设计一个时间复杂度为`O(nlgk)`的算法，能将k个有序的链表合并成一个有序的链表，使用最小堆完成合并。

分析：[实现代码](../src/algorithms/ch6-heap/merge_kchains.cpp)

使用暴力算法也能很方便的解决该问题，然而其复杂度是`O(nk)`，为了将算法优化到`O(nlogk)`，在合并过程中，应当使用最小堆。

在合并时，每个链表都有一个索引指针，指向当前未被合并的位置，将这些指针指向的值全部放入到堆，整堆过程会把最小值放在堆顶。这需要`O(logk)`的时间，取出的最小值放入新的有序链表，然后将索引指针++即可。