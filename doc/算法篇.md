# 算法篇

[TOC]

## 排序

### 逆序对数量

问题：假设A[1..n]是一个有n个不同数的数组，若`i<j`且`a[i]>a[j]`，则对偶`(i, j)`称为A的一个逆序对(inversion)。给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况下需要`o(nlgn)`的时间复杂度。

分析：[实现代码](../src/algorithms/ch2-base/inversion.cpp)

算法的思路是从**排序的过程**中来计算逆序对，因为排序正是修正逆序的过程。既然复杂度要控制在`O(nlgn)`以内，以现在接触的算法来说，可选用归并排序。

那么归并排序的过程中如何去确定逆序对的数量呢？首先，对于归并排序来讲，分解、解决、合并三步里的合并步骤是解决问题的关键，在**合并**这一步中，L与R两个子数组中的数都是相对有序的，并且L数组的下标都是小于R数组的下标的。这样一来，**出现逆序对的地方，就只能是在L中出现某个值x比R数组中的值y大**。并且，排在x之后的所有值也必然要比y的值要大，这样我们就求得了在当前合并步骤中与y相关的逆序对的总量。

那么这样计算有无遗漏呢？由于在归并排序中，每次从L、R数组中取出的数都是**未排元素中的最小值**。因此不会出现R数组中的某数y丢失逆序对的情况，因为此时L数组中所有的已经归并的元素绝不可能比y要大。

## 堆

### 合并k个链表

问题：设计一个时间复杂度为`O(nlgk)`的算法，能将k个有序的链表合并成一个有序的链表，使用最小堆完成合并。

分析：[实现代码](../src/algorithms/ch6-heap/merge_kchains.cpp)

使用暴力算法也能很方便的解决该问题，然而其复杂度是`O(nk)`，为了将算法优化到`O(nlogk)`，在合并过程中，应当使用最小堆。

在合并时，每个链表都有一个索引指针，指向当前未被合并的位置，将这些指针指向的值全部放入到堆，整堆过程会把最小值放在堆顶。这需要`O(logk)`的时间，取出的最小值放入新的有序链表，然后将索引指针++即可。

## 队列

### 二叉树的层次遍历

问题：给定一个二叉树，要求对二叉树进行层次遍历。

分析：[实现代码](../src/algorithms/ch10-basestructure/traverse.cpp)

二叉树层次遍历相对于先序遍历等较为复杂，这里做简单的分析。首先明白，二叉树的从上到下遍历就是宽度优先搜索法，那么就不得不利用**队列**来安排节点的访问顺序。

具体做法是，从队首中取出节点，并访问，之后，就应当立即将它的左右子节点（若存在的话）入队列，队列的先入先出特性可以保证访问次序。这其中，为确定层数，可以记录在每次循环开始前队列的大小，保证这次循环都在处理同一层。

## 分治策略

### 最大子数组问题

问题：给定一列数组，其表示股票市场中某股票价格的涨幅，用程序计算出买入、卖出的最合适时间点，并给出最大收益值。

分析：[实现代码]

为获得最大的收益，肯定先考虑低价买入，高价卖出。然而应当如何确定这个时间点呢？暴力可以解决这个问题，但是时间复杂度为`O(n^2)`，还有无更好的方法了？

显然，我们不需要关系股票的实际价格，只需要关心股票与前一天相比的差价就行。那么，将数据转换为一列价格变化时，问题就转换为了寻找数组中的和最大的非空子数组问题。该问题用动态规划方法可以获得线性时间的复杂度，但这里使用分治策略，为的是打开思路。

分治策略要求将数组一分为二，分别求出前半部分的最大子数组和后半部分的最大子数组，当然这会遗漏掉横跨中间线的子数组，因此还需要考虑这一个情况。将这三种情况求得的最大子数组的值进行比较，就可以得到原问题的最大子数组值。伪代码如下：

```
Find_Max_Subarray(A, low, high):
	if high == low:
		return (low, high, A[low])
	else:
    	mid = (low + high) / 2
		left_low, left_high, left_sum = Find_Max_Subarray(A, low, mid)
		right_low, right_high, right_sum = Find_Max_Subarray(A, mid, high)
		cross_low, cross_high, cross_sum = Find_Max_Cross(A, low, mid, high)
		
		return max(left, right, sum)
```



