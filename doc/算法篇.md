# 算法篇

[TOC]

## 排序

### 逆序对数量

问题：假设A[1..n]是一个有n个不同数的数组，若`i<j`且`a[i]>a[j]`，则对偶`(i, j)`称为A的一个逆序对(inversion)。给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况下需要`o(nlgn)`的时间复杂度。

分析：[实现代码](../src/algorithms/ch2-base/inversion.cpp)

算法的思路是从**排序的过程**中来计算逆序对，因为排序正是修正逆序的过程。既然复杂度要控制在`O(nlgn)`以内，以现在接触的算法来说，可选用归并排序。

那么归并排序的过程中如何去确定逆序对的数量呢？首先，对于归并排序来讲，分解、解决、合并三步里的合并步骤是解决问题的关键，在**合并**这一步中，L与R两个子数组中的数都是相对有序的，并且L数组的下标都是小于R数组的下标的。这样一来，**出现逆序对的地方，就只能是在L中出现某个值x比R数组中的值y大**。并且，排在x之后的所有值也必然要比y的值要大，这样我们就求得了在当前合并步骤中与y相关的逆序对的总量。

那么这样计算有无遗漏呢？由于在归并排序中，每次从L、R数组中取出的数都是**未排元素中的最小值**。因此不会出现R数组中的某数y丢失逆序对的情况，因为此时L数组中所有的已经归并的元素绝不可能比y要大。

## 堆

### 合并k个链表

问题：设计一个时间复杂度为`O(nlgk)`的算法，能将k个有序的链表合并成一个有序的链表，使用最小堆完成合并。

分析：[实现代码](../src/algorithms/ch6-heap/merge_kchains.cpp)

使用暴力算法也能很方便的解决该问题，然而其复杂度是`O(nk)`，为了将算法优化到`O(nlogk)`，在合并过程中，应当使用最小堆。

在合并时，每个链表都有一个索引指针，指向当前未被合并的位置，将这些指针指向的值全部放入到堆，整堆过程会把最小值放在堆顶。这需要`O(logk)`的时间，取出的最小值放入新的有序链表，然后将索引指针++即可。

## 队列

### 二叉树的层次遍历

问题：给定一个二叉树，要求对二叉树进行层次遍历。

分析：[实现代码](../src/algorithms/ch10-basestructure/traverse.cpp)

二叉树层次遍历相对于先序遍历等较为复杂，这里做简单的分析。首先明白，二叉树的从上到下遍历就是宽度优先搜索法，那么就不得不利用**队列**来安排节点的访问顺序。

具体做法是，从队首中取出节点，并访问，之后，就应当立即将它的左右子节点（若存在的话）入队列，队列的先入先出特性可以保证访问次序。这其中，为确定层数，可以记录在每次循环开始前队列的大小，保证这次循环都在处理同一层。

## 分治策略

### 最大子数组问题

问题：给定一列数组，其表示股票市场中某股票价格的涨幅，用程序计算出买入、卖出的最合适时间点，并给出最大收益值。

分析：[实现代码]

为获得最大的收益，肯定先考虑低价买入，高价卖出。然而应当如何确定这个时间点呢？暴力可以解决这个问题，但是时间复杂度为`O(n^2)`，还有无更好的方法了？

显然，我们不需要关系股票的实际价格，只需要关心股票与前一天相比的差价就行。那么，将数据转换为一列价格变化时，问题就转换为了寻找数组中的和最大的非空子数组问题。该问题用动态规划方法可以获得线性时间的复杂度，但这里使用分治策略，为的是打开思路。

分治策略要求将数组一分为二，分别求出前半部分的最大子数组和后半部分的最大子数组，当然这会遗漏掉横跨中间线的子数组，因此还需要考虑这一个情况。将这三种情况求得的最大子数组的值进行比较，就可以得到原问题的最大子数组值。伪代码如下：

```
Find_Max_Subarray(A, low, high):
	if high == low:
		return (low, high, A[low])
	else:
    	mid = (low + high) / 2
		left_low, left_high, left_sum = Find_Max_Subarray(A, low, mid)
		right_low, right_high, right_sum = Find_Max_Subarray(A, mid, high)
		cross_low, cross_high, cross_sum = Find_Max_Cross(A, low, mid, high)
		
		return max(left, right, sum)
```

## 动态规划

### 单词拆分

问题描述：给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
示例 1：

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```


示例 2：

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

思路分析：使用动态规划的关键在于，找到前后项的转移关系。在本题中，定义字符串 s 的前 i 个字符组成的字符串 s[0..i-1] ，我们要寻找前 i 个字符与前 i-1个字符之间的相互联系。

接下来就是重点了，定义动态规划数组 dp[] 。我们把字符串 s[0..i-1] 看做原问题的输入，而把 dp[i] 作为对这个问题的回答（true or false）。

再从字符串前后关系中寻找转移方程。从单词的分解过程来看，如果答案为 true ，将 s[0..i-1] 再细分为两个字符串 s1 和 s2 ，其中 s2 必须是个单词，s1 可以是一个单词，也可以是几个单词的组合。假设这个分割点是 j ，那么意味着对 s1 的回答就是原问题的子问题，它的答案就是 dp[j] ，而 s2 就需要我们进一步确定，那么转移方程就可以写为，dp[i] = dp[j] and s[j..i-1] 。那么 s[j..i-1] 字符串是否是单词，就需要遍历词典确定了。

最后一个小问题，就是 dp[0] 值是 true 还是 false 。需要慎重考虑

题外话：动态规划的迷人之处在于，思考问题的过程与求解问题的过程是相反的。思考问题是，更像是把大问题拆为小问题，而求解时却必须从最简单的情况入手，逐步推导到原问题。

```C++
bool wordBreak(string s, vector<string>& wordDict) {
	auto wordDictSet = unordered_set <string> ();
    for (auto word: wordDict) {
		wordDictSet.insert(word);
    }

    auto dp = vector <bool> (s.size() + 1);
	dp[0] = true;
    for (int i = 1; i <= s.size(); ++i) {
	  for (int j = 0; j < i; ++j) {
        if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
        }
      }
    }
	return dp[s.size()];
}
```

